TODOs:
  Add various todos here

  ☐ Emigrate the code to the Arduino Mega
    ☐ The cppm library might have to be customized to support the mega

  ☐ Implement the stepper motor for the lidar system
    It will be controlled with an H-bridge and probably the accelStepper library
  ☐ Implement the sound card to bea able to play sounds
    The one we have is a Adafruit Mini Audio FX board 16Mb
  ☐ Add an LCD screen for information, status, mode etc.
    The one we have is a BT21605AV which uses I2C communication
  ☐ Make it so that the radio reciever is diabled if the controller is not turned on
    Right now if the controller is not on when the platform is on weird things can happen
    The platform should be able to sense when there is not radio signals being recieved
  ☐ Add serial communication support to talk to the WIFI module
    the wifi module will talk to the computer and both recieve and send data
  ☐ Create a communication protocol/class for sending sensor data
    It would be nice to have one unit controlling gathering and sending of the sendor data
  ☐ Change the pinmap for the arduino mega in settings.h
    Currently it is just the same as the UNO

  Sensors:
    ☐ Add accelerometer/gyro to the platform
    These two might not be that neccesary so the priority is not that high
    ☐ Implement proximity sensors
      ☐ Test the sharp IR sensor
      ☐ Create linear interpolation and calibrate the sensor data
      The sensors won't give linearly increasing values with distance
    ☐ Implement the TFmini on the arduino MEGA
      The TFmini is connected to the I2c bus. So is the Magnetometer. There should not be a problem
      since both are slaves but we have to make sure this is the case.
  ☐ Fix so that the timers work for the arduino Mega
    Right now the arduino crashes at startup either when initializing the timers or the first time they are set.
    This could have to do with timers on the MEGA2560 being different than the UNO
    It could also be because of a collision with the jmCPPM library that i modified to support the MEGA

  PID:
    in the case of eg. the rotation 0-360
    ☐ If a PID controller should be used a solution for integrator saturation has to be implemented
    ☐ Discrete controler -> Time, T_s, between each measurement has to be decided
    
  Others:
    ☐ Comment already created code.. @project(TODOs) @started(18-11-07 09:41)
      ☐ Use "/* some text */" to comment what functions do
    This is a stupid task and it should be done when the code is written...

Archive:
  ✔ Add support for wraparound @done(18-11-20 14:05) @project(TODOs.PID)
  ✔ Add different modes for the platform @done(18-11-12 09:53) @project(TODOs)
    For examle manual, automatic driving, lidar sensor mode etc.
    This will basically be a state machine in the platform class.
  ✔ Fix the problem with not being able to use non-static member functions in callbacks @started(18-11-12 09:03) @done(18-11-12 09:04) @lasted(1m1s) @project(TODOs.Timer)
    There is currently a big problem with this class.
    Right now the callback function has to be static which means that 
    if it is not global (which it should not be) the callback function cannot use any
    private member variable or functions (which most of them do...).alignas
    One solution to this is to implement boost:: which allows non-static member functions
    in a callback. https://github.com/vancegroup/arduino-boost
    Could the timers be handled without callback functions?
    SOLUTION, I remade the timer class so that they dont have callback functions.
    Instead you now check the timers in that platform and run functions conditionally
  ✔ Test the mini LIDAR @done(18-11-11 19:56) @project(TODOs)
  ✔ Implement a timer class that can keep track of timers @started(18-11-11 20:38) @done(18-11-11 20:38) @lasted(31s) @project(TODOs)
    This can be usefull if we want to do certain tasks only once in a while
    like for example reading a sensor or sending the sensor value to the GUI
  ✔ Create PID class so that we can create and use PID controllers for the platform @started(18-11-10 12:44) @done(18-11-10 13:18) @lasted(34m31s) @project(TODOs)
    The first one i want is one that rotates the robot to a certain heading and uses the compass as the feedback
  ✔ Test the new class implementation of the platform and the radio @done(18-11-10 11:25) @project(TODOs)
    The code compiles but is not tested
  ✔ Implement the GY-85 Magnetometer in a class @started(18-11-09 22:22) @done(18-11-09 22:22) @lasted(29s) @project(TODOs)
  ✔ Embedd the sensor data in a good way to be able to send it easy @started(18-11-09 21:22) @done(18-11-09 22:22) @lasted(1h44s) @project(TODOs)
    Should we send chars/int/double/float?
  ✔ Change motor handling so that it doesn't have to be driven with cppm @started(18-11-05 18:56) @done(18-11-06 19:11) @lasted(1d15m56s) @project(TODOs)
    This is so that the motors can be driven in an easy way during autonomous drive
  ✔ Move the radio class into the platform @started(18-11-06 14:11) @done(18-11-06 18:57) @lasted(4h46m45s) @project(TODOs)
    The radio is right now separate using global variables
  ✔ Make the platform into a class @started(18-11-06 11:51) @done(18-11-06 12:34) @lasted(43m29s) @project(TODOs)
    This is so that we can store speed, direction etc in the class
  